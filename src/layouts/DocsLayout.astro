---
import '../styles/global.css';
import Sidebar from '../components/Sidebar.astro';
import TableOfContents from '../components/TableOfContents.astro';
import FeedbackForm from '../components/FeedbackForm.astro';
import Header from '../components/Header.astro';
import Breadcrumbs from '../components/Breadcrumbs.astro';
import ZoomLightbox from '../components/ZoomLightbox.astro';
import Footer from '../components/Footer.astro';
import { ClientRouter } from 'astro:transitions';

interface Props {
  title: string;
  sidebarData: any[];
  currentPlatformId: string;
  currentSlug: string;
  headings?: { depth: number; slug: string; text: string }[];
  breadcrumbs?: { label: string; href?: string }[];
  description?: string;
  metadataTitle?: string;
  keywords?: string | string[];
  rank?: number;
  isFullWidth?: boolean;
}

const { title, sidebarData, currentPlatformId, currentSlug, headings = [], breadcrumbs = [], description, metadataTitle, keywords, rank, isFullWidth = false } = Astro.props;

const derivedTitle = metadataTitle || title;
const keywordsString = Array.isArray(keywords) ? keywords.join(', ') : keywords;

const canonicalURL = new URL(Astro.url.pathname, Astro.site);
if (canonicalURL.pathname.length > 1 && canonicalURL.pathname.endsWith('/')) {
  canonicalURL.pathname = canonicalURL.pathname.slice(0, -1);
}
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href={`${import.meta.env.BASE_URL}/favicon_black.svg`.replace(/\/+/g, '/')} />
    <meta name="generator" content={Astro.generator} />
    <title>{derivedTitle}</title>
    <link rel="canonical" href={canonicalURL.href} />

    <!-- Google Tag Manager -->
    <script is:inline>
      (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-PXJV3N7');
    </script>
    
    <!-- Survicate -->
    <script is:inline>
      window._sva = window._sva || {};
    </script>
    <script src="https://survey.survicate.com/workspaces/af55d3f51f8189593de1c948b75c88f6/web_surveys.js" async></script>
    
    <!-- Theme initialization (before page render to avoid flash) -->
    <script is:inline>
      // Initialize theme immediately
      (function() {
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        }
      })();
    </script>
    {description && (
      <>
        <meta data-rh="true" name="description" content={description} />
        <meta data-rh="true" property="og:description" content={description} />
      </>
    )}
    {keywordsString && <meta name="keywords" content={keywordsString} data-rh="true" />}
    {rank !== undefined && <meta name="rank" content={String(rank)} data-rh="true" />}
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    {isFullWidth ? null : <ClientRouter />}
    <meta name="google-site-verification" content="4rYXBX10-ZGpLJrZkkzyfbgqkF3U5cN92QgVovT6GFU" />
  </head>
  <body class:list={["font-sans docs-body", isFullWidth ? "h-[100dvh] flex flex-col overflow-hidden" : "min-h-[100dvh]"]}>
    <!-- Google Tag Manager (noscript) -->
    <noscript>
      <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PXJV3N7"
      height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    
    <!-- Persistent container for LiveChat widget to survive Astro transitions -->
    <div id="livechat-persist-container" data-astro-transition-persist="livechat-container"></div>
    
    <Header />
    
    <!-- Mobile Search Overlay -->
    <div id="mobile-search-overlay" class="mobile-search-overlay" aria-hidden="true">
      <div class="mobile-search-container">
        <div class="mobile-search-header">
          <div class="relative flex-1">
            <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none mobile-search-icon">
              <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </div>
            <input
              type="text"
              id="mobile-search-input"
              placeholder="Search documentation..."
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
              class="block w-full pl-12 pr-4 py-3.5 border-0 text-base focus:outline-none"
            />
          </div>
          <button id="mobile-search-close" class="mobile-search-close-btn p-3">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
          </button>
        </div>
        <div id="mobile-search-results" class="mobile-search-results">
          <!-- Results will be injected here -->
        </div>
      </div>
    </div>
    
    <div class:list={["relative", isFullWidth ? "flex-1 overflow-hidden" : "flex"]}>
        {/* Main Content Area â€” first in DOM for content-first ordering */}
        <main class:list={[
            "flex-1 min-w-0 transition-all duration-300",
            isFullWidth ? "h-full" : (!isFullWidth && sidebarData ? "lg:ml-72" : "mx-auto max-w-6xl")
        ]}>
            
            <div class:list={[
                "flex",
                isFullWidth ? "w-full px-0 h-full items-start" : "px-4 sm:px-6 md:px-8 lg:px-10 xl:px-12 2xl:px-16 py-6 lg:py-8 gap-8 xl:gap-12 2xl:gap-16 items-start"
            ]}>
                <article class:list={[
                    isFullWidth ? "w-full h-full" : "flex-1 min-w-0 max-w-4xl prose prose-slate dark:prose-invert docs-prose",
                    !isFullWidth && "prose-headings:font-bold prose-headings:tracking-tight prose-headings:scroll-mt-24",
                    !isFullWidth && "prose-h1:text-3xl lg:prose-h1:text-4xl prose-h1:mb-6 lg:prose-h1:mb-8",
                    !isFullWidth && "prose-a:font-medium prose-a:no-underline prose-a:hover:underline",
                    !isFullWidth && "prose-img:rounded-2xl prose-img:shadow-xl",
                    !isFullWidth && "prose-pre:rounded-2xl prose-pre:shadow-2xl",
                    !isFullWidth && "prose-blockquote:border-l-4 prose-blockquote:py-2 prose-blockquote:px-6 prose-blockquote:rounded-r-2xl prose-blockquote:not-italic",
                    !isFullWidth && "prose-strong:font-semibold",
                    !isFullWidth && "max-w-[75ch]",
                    !isFullWidth ? "xl:max-w-none" : ""
                ]}>
                    {!isFullWidth && (
                        <div class="lg:mb-0 mb-4 overflow-x-auto scrollbar-hide">
                            <Breadcrumbs items={breadcrumbs} />
                        </div>
                    )}
                    <slot />
                </article>

                {!isFullWidth && (
                    <div class="right-column-wrapper">
                        {headings.filter(h => h.depth >= 2 && h.depth <= 3).length > 0 && (
                            <TableOfContents headings={headings} />
                        )}
                        <FeedbackForm hasToC={headings.filter(h => h.depth >= 2 && h.depth <= 3).length > 0} />
                    </div>
                )}
            </div>
            
            {!isFullWidth && <Footer />}
        </main>

        <!-- Mobile Overlay -->
        <div id="sidebar-overlay" class="sidebar-overlay" aria-hidden="true"></div>

        {!isFullWidth && sidebarData && (
             <Sidebar
                sidebarData={sidebarData}
                currentPlatformId={currentPlatformId}
                currentSlug={currentSlug}
            />
        )}
    </div>

    <!-- Initialize theme script -->
    <script>
      import { initTheme } from '../scripts/theme';
      initTheme();
    </script>
    
    <!-- Prevent horizontal jump during view transitions -->
    <script>
      // Lock viewport width ONLY during Astro view transitions to prevent scrollbar flicker
      let lockedWidth = null;
      
      function lockWidth() {
        // Capture current width including scrollbar
        if (!lockedWidth) {
          lockedWidth = document.documentElement.clientWidth + 'px';
        }
        // Lock the width
        document.documentElement.style.setProperty('min-width', lockedWidth, 'important');
        document.documentElement.style.setProperty('max-width', lockedWidth, 'important');
        document.documentElement.style.setProperty('overflow-y', 'scroll', 'important');
      }
      
      function unlockWidth() {
        // Remove width locks after transition completes
        setTimeout(() => {
          document.documentElement.style.removeProperty('min-width');
          document.documentElement.style.removeProperty('max-width');
          lockedWidth = null;
        }, 50);
      }
      
      document.addEventListener('astro:before-preparation', lockWidth);
      document.addEventListener('astro:before-swap', lockWidth);
      document.addEventListener('astro:after-swap', () => {
        lockWidth();
        unlockWidth();
      });
    </script>
    
    
    <!-- Mobile Sidebar Toggle -->
    <script>
      // Use event delegation on document to avoid duplicate listeners
      document.addEventListener('click', (e) => {
        // Use composedPath to penetrate Shadow DOM (Stoplight Elements)
        const path = e.composedPath();
        const isInApiContainer = path.some(el => el.classList?.contains('api-container'));

        // Skip for clicks inside Stoplight to avoid stealing focus or triggering state changes
        if (isInApiContainer) return;

        const target = e.target as HTMLElement;
        
        // Check if click is on mobile menu button or its children
        const mobileMenuBtn = target.closest('#mobile-menu-btn');
        if (mobileMenuBtn) {
          e.preventDefault();
          e.stopPropagation();
          
          const sidebar = document.getElementById('main-sidebar');
          const overlay = document.getElementById('sidebar-overlay');
          
          if (!sidebar || !overlay) return;
          
          const isOpen = sidebar.getAttribute('data-open') === 'true';
          
          if (isOpen) {
            // Close sidebar
            sidebar.style.transform = 'translateX(-100%)';
            sidebar.setAttribute('data-open', 'false');
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
            document.body.style.overflow = '';
          } else {
            // Open sidebar
            sidebar.style.transform = 'translateX(0)';
            sidebar.setAttribute('data-open', 'true');
            overlay.style.opacity = '1';
            overlay.style.pointerEvents = 'auto';
            document.body.style.overflow = 'hidden';
          }
          return;
        }
        
        // Check if click is on close button or its children
        const closeBtn = target.closest('#sidebar-close-btn');
        if (closeBtn) {
          const sidebar = document.getElementById('main-sidebar');
          const overlay = document.getElementById('sidebar-overlay');
          
          if (!sidebar || !overlay) return;
          
          sidebar.style.transform = 'translateX(-100%)';
          sidebar.setAttribute('data-open', 'false');
          overlay.style.opacity = '0';
          overlay.style.pointerEvents = 'none';
          document.body.style.overflow = '';
          return;
        }
        
        // Check if click is on overlay
        const overlayElement = target.closest('#sidebar-overlay');
        if (overlayElement) {
          const sidebar = document.getElementById('main-sidebar');
          
          if (!sidebar) return;
          
          sidebar.style.transform = 'translateX(-100%)';
          sidebar.setAttribute('data-open', 'false');
          overlayElement.style.opacity = '0';
          overlayElement.style.pointerEvents = 'none';
          document.body.style.overflow = '';
          return;
        }
      });
      
      // Reset sidebar state based on viewport size
      function resetSidebarOnResize() {
        const sidebar = document.getElementById('main-sidebar');
        const overlay = document.getElementById('sidebar-overlay');
        
        if (!sidebar || !overlay) return;
        
        const isDesktop = window.innerWidth >= 1024; // lg breakpoint
        
        if (isDesktop) {
          // On desktop: ensure sidebar is visible and reset mobile state
          sidebar.style.transform = 'translateX(0)';
          sidebar.setAttribute('data-open', 'false');
          overlay.style.opacity = '0';
          overlay.style.pointerEvents = 'none';
          document.body.style.overflow = '';
        } else {
          // On mobile: close sidebar if it's not explicitly open
          const isOpen = sidebar.getAttribute('data-open') === 'true';
          if (!isOpen) {
            sidebar.style.transform = 'translateX(-100%)';
          }
        }
      }
      
      // Initialize data-open attribute on page load
      function initSidebarState() {
        const sidebar = document.getElementById('main-sidebar');
        if (sidebar && !sidebar.hasAttribute('data-open')) {
          sidebar.setAttribute('data-open', 'false');
        }
        resetSidebarOnResize();
      }
      
      // Listen for viewport changes (zoom, resize)
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(resetSidebarOnResize, 150);
      });
      
      initSidebarState();
      document.addEventListener('astro:page-load', initSidebarState);
    </script>
    
    <!-- Mobile Search Toggle -->
    <script>
      // Handle mobile search overlay
      document.addEventListener('click', (e) => {
        const path = e.composedPath();
        const isInApiContainer = path.some(el => el.classList?.contains('api-container'));

        // Skip for clicks inside Stoplight to avoid interfering with its internal UI
        if (isInApiContainer) return;

        const target = e.target as HTMLElement;
        
        // Open mobile search
        const searchBtn = target.closest('#mobile-search-btn');
        if (searchBtn) {
          e.preventDefault();
          const overlay = document.getElementById('mobile-search-overlay');
          const input = document.getElementById('mobile-search-input') as HTMLInputElement;
          
          if (overlay && input) {
            overlay.setAttribute('data-open', 'true');
            document.body.style.overflow = 'hidden';
            // Focus input after a short delay to ensure overlay is visible
            setTimeout(() => input.focus(), 100);
          }
          return;
        }
        
        // Close mobile search
        const closeBtn = target.closest('#mobile-search-close');
        if (closeBtn) {
          const overlay = document.getElementById('mobile-search-overlay');
          const input = document.getElementById('mobile-search-input') as HTMLInputElement;
          
          if (overlay && input) {
            overlay.setAttribute('data-open', 'false');
            document.body.style.overflow = '';
            input.value = '';
            const resultsContainer = document.getElementById('mobile-search-results');
            if (resultsContainer) resultsContainer.innerHTML = '';
          }
          return;
        }
      });
      
      // Close mobile search on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const overlay = document.getElementById('mobile-search-overlay');
          if (overlay && overlay.getAttribute('data-open') === 'true') {
            overlay.setAttribute('data-open', 'false');
            document.body.style.overflow = '';
            const input = document.getElementById('mobile-search-input') as HTMLInputElement;
            if (input) input.value = '';
            const resultsContainer = document.getElementById('mobile-search-results');
            if (resultsContainer) resultsContainer.innerHTML = '';
          }
        }
      });
      
      // Mobile search functionality
      async function initMobileSearch() {
        const mobileSearchInput = document.getElementById('mobile-search-input') as HTMLInputElement;
        const mobileSearchResults = document.getElementById('mobile-search-results');
        const desktopSearchInput = document.getElementById('search-input') as HTMLInputElement;
        
        if (!mobileSearchInput || !mobileSearchResults || !desktopSearchInput) return;
        
        // Get Algolia credentials from desktop search input
        const appId = desktopSearchInput.dataset.appId;
        const apiKey = desktopSearchInput.dataset.apiKey;
        const indexName = desktopSearchInput.dataset.indexName;
        const analyticsKey = desktopSearchInput.dataset.analyticsKey || apiKey;
        
        if (!appId || !apiKey || !indexName) return;
        
        // Import Algolia dynamically
        const { liteClient: algoliasearch } = await import('algoliasearch/lite');
        const client = algoliasearch(appId, apiKey);
        
        function getOrCreateUserToken() {
          let token = localStorage.getItem('algolia_user_token');
          if (!token) {
            token = 'user-' + Math.random().toString(36).substring(2, 15);
            localStorage.setItem('algolia_user_token', token);
          }
          return token;
        }
        
        function transformUrlForEnvironment(originalUrl: string): string {
          const currentOrigin = window.location.origin;
          const baseUrl = import.meta.env.BASE_URL;
          const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const isVercel = window.location.hostname.includes('vercel.app');
          const isProduction = window.location.hostname === 'adapty.io';
          
          let url = originalUrl;
          if (url.startsWith('https://adapty.io/docs/')) {
            if (isLocalhost || isVercel || !isProduction) {
              const path = url.replace('https://adapty.io/docs/', '');
              url = `${currentOrigin}${baseUrl}/${path}`.replace(/(?<!:)\/+/g, '/');
            }
          }
          return url;
        }
        
        async function performMobileSearch(query: string) {
          if (!query) {
            mobileSearchResults.innerHTML = '';
            return;
          }
          
          try {
            const { results } = await client.search([{
              indexName,
              params: {
                query,
                hitsPerPage: 20,
                attributesToRetrieve: ['*'],
                clickAnalytics: true,
                userToken: getOrCreateUserToken(),
              },
            }]);
            
            const searchResponse = (results as any)[0];
            const hits = searchResponse.hits;
            const queryID = searchResponse.queryID;
            
            renderMobileResults(hits, queryID);
          } catch (error) {
            console.error('Mobile search error:', error);
          }
        }
        
        function renderMobileResults(hits: any[], queryID: string) {
          if (hits.length === 0) {
            mobileSearchResults.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-tertiary);">No results found.</div>';
            return;
          }
          
          mobileSearchResults.innerHTML = '';
          hits.forEach((hit, index) => {
            const item = document.createElement('a');
            const originalUrl = hit.url || hit.objectID;
            const navigationUrl = transformUrlForEnvironment(originalUrl);
            
            item.href = navigationUrl;
            
            item.addEventListener('click', (e) => {
              e.preventDefault();
              
              // Send analytics
              const eventData = {
                events: [{
                  eventType: 'click',
                  eventName: 'Search Result Clicked',
                  index: indexName,
                  queryID: queryID,
                  objectIDs: [hit.objectID],
                  positions: [index + 1],
                  userToken: getOrCreateUserToken(),
                }],
              };
              
              fetch(`https://insights.algolia.io/1/events`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Algolia-Application-Id': appId || '',
                  'X-Algolia-API-Key': analyticsKey || '',
                },
                body: JSON.stringify(eventData)
              }).catch(console.error);
              
              setTimeout(() => {
                window.location.href = navigationUrl;
              }, 150);
            });
            
            const title = hit.hierarchy.lvl1 || hit.hierarchy.lvl2 || hit.hierarchy.lvl0 || 'Documentation';
            const breadcrumbs = [];
            if (hit.hierarchy.lvl0) breadcrumbs.push(hit.hierarchy.lvl0);
            if (hit.hierarchy.lvl1 && hit.hierarchy.lvl1 !== title) breadcrumbs.push(hit.hierarchy.lvl1);
            
            const breadcrumbsHtml = breadcrumbs.length
              ? `<div class="result-breadcrumbs">${breadcrumbs.join(' / ')}</div>`
              : '';
            
            item.innerHTML = `
              ${breadcrumbsHtml}
              <div class="result-title">${title}</div>
              ${hit.description ? `<div class="result-description">${hit.description}</div>` : ''}
            `;
            
            mobileSearchResults.appendChild(item);
          });
        }
        
        let debounceTimer: ReturnType<typeof setTimeout>;
        mobileSearchInput.addEventListener('input', (e) => {
          const query = (e.target as HTMLInputElement).value.trim();
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => performMobileSearch(query), 150);
        });
      }
      
      // Initialize mobile search
      initMobileSearch();
      document.addEventListener('astro:page-load', initMobileSearch);
    </script>
    
    <!-- LiveChat Widget - Cloud Controlled -->
    <script is:inline>
      (function() {
        // Prevent duplicate script loading
        if (window.__livechatScriptLoaded) return;
        window.__livechatScriptLoaded = true;
        
        var s = document.createElement('script');
        s.src = 'https://back.sirius.ws/api/public/livechat/widget/b326501f-0bc9-467d-89fd-c5f9ef1eb573/script.js';
        s.async = true;
        s.id = 'livechat-widget-script';
        document.body.appendChild(s);
      })();

      // Inject "Ask AI" label next to the widget and persist across navigation
      (function() {
        function initLivechatLabel() {
          // Skip for API pages to avoid noise and interference
          if (window.__isApiReferencePage) return;

          const persistContainer = document.getElementById('livechat-persist-container');
          if (!persistContainer) return;

          function moveWidgetToPersistentContainer() {
            const widget = document.getElementById('livechat-widget-button');
            if (!widget) return;
            
            // Move widget to persistent container if not already there
            if (widget.parentElement !== persistContainer) {
              persistContainer.appendChild(widget);
            }
          }

          function injectLabel() {
            if (document.getElementById('ask-ai-label')) return;
            const widget = document.getElementById('livechat-widget-button');
            if (!widget) return;

            const label = document.createElement('div');
            label.id = 'ask-ai-label';
            label.innerText = 'Ask AI';
            label.className = 'ask-ai-widget-label';
            
            // Add to persistent container
            persistContainer.appendChild(label);
          }

          // Move any livechat-related elements to persistent container
          function persistWidgetElements() {
            // Look for all livechat widget elements
            const widgetSelectors = [
              '#livechat-widget-button',
              '#livechat-widget-container',
              '[id^="livechat"]',
              '[class*="livechat"]'
            ];
            
            widgetSelectors.forEach(selector => {
              try {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                  // Move to persistent container if it's a direct child of body
                  if (el.parentElement === document.body && el !== persistContainer) {
                    persistContainer.appendChild(el);
                  }
                });
              } catch (e) {
                // Ignore invalid selectors
              }
            });
          }

          // Only inject style once
          if (!document.getElementById('ask-ai-label-style')) {
            const style = document.createElement('style');
            style.id = 'ask-ai-label-style';
            style.textContent = `
              .ask-ai-widget-label {
                position: fixed;
                bottom: 20px;
                right: 88px;
                height: 60px; /* Match widget height for perfect centering */
                display: flex;
                align-items: center;
                color: var(--accent-primary);
                font-weight: 700;
                font-size: 18px;
                cursor: default;
                z-index: 9998;
                transition: all 0.2s ease;
                font-family: 'Inter', system-ui, sans-serif;
                opacity: 0;
                transform: translateX(5px);
                animation: askAiLabelFadeIn 0.6s ease forwards;
                white-space: nowrap;
                user-select: none;
                letter-spacing: -0.01em;
              }

              @keyframes askAiLabelFadeIn {
                to {
                  opacity: 1;
                  transform: translateX(0);
                }
              }

              @media (max-width: 1024px) {
                .ask-ai-widget-label {
                  display: none;
                }
              }
              
              /* LiveChat Widget Dark Mode Overrides */
              html.dark #livechat-widget-container,
              html.dark [id*="livechat-widget"] {
                background-color: #1e293b !important;
              }
              
              html.dark #livechat-widget-container *,
              html.dark [id*="livechat-widget"] * {
                color: #f1f5f9 !important;
              }
              
              html.dark [id*="livechat-widget"] p,
              html.dark [id*="livechat-widget"] span,
              html.dark [id*="livechat-widget"] div:not([role="img"]) {
                color: #f1f5f9 !important;
              }
              
              /* Livechat input fields in dark mode */
              html.dark [id*="livechat"] input,
              html.dark [id*="livechat"] textarea {
                background-color: #0f172a !important;
                color: #f1f5f9 !important;
                border-color: #334155 !important;
              }
              
              html.dark [id*="livechat"] input::placeholder,
              html.dark [id*="livechat"] textarea::placeholder {
                color: #94a3b8 !important;
              }
            `;
            document.head.appendChild(style);
          }

          // Clean up old observer if exists
          if (window.__livechatObserver) {
            window.__livechatObserver.disconnect();
          }

          // Create new observer to watch for widget creation
          window.__livechatObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.addedNodes.length > 0) {
                // Check if any added nodes are livechat related
                mutation.addedNodes.forEach(node => {
                  if (node.nodeType === 1) { // Element node
                    const el = node;
                    if (el.id && (el.id.includes('livechat') || el.id === 'ask-ai-label')) {
                      // Skip if it's already in the persistent container
                      if (el.parentElement === persistContainer) return;
                      
                      // Move to persistent container
                      if (el.parentElement === document.body) {
                        persistContainer.appendChild(el);
                      }
                    }
                  }
                });
                
                // Run our functions
                moveWidgetToPersistentContainer();
                injectLabel();
                persistWidgetElements();
              }
            }
          });

          window.__livechatObserver.observe(document.body, { 
            childList: true, 
            subtree: false // Only watch direct children of body
          });
          
          // Run immediately in case widget already exists
          moveWidgetToPersistentContainer();
          injectLabel();
          persistWidgetElements();
        }
        
        // Initialize on load
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', initLivechatLabel);
        } else {
          initLivechatLabel();
        }
        
        // Re-initialize on page transitions (Astro View Transitions)
        document.addEventListener('astro:page-load', initLivechatLabel);
        document.addEventListener('astro:after-swap', initLivechatLabel);
      })();
    </script>
    <!-- End LiveChat Widget -->

    <script>
      function enhanceCodeBlocks() {
        // Skip for API pages to avoid interfering with Stoplight Elements
        if (window.__isApiReferencePage) return;

        const preElements = document.querySelectorAll('article pre:not(.processed)');
        const isDark = document.documentElement.classList.contains('dark');
        
        preElements.forEach((pre, index) => {
          pre.classList.add('processed');
          
          // Mark that JS has processed this element (for CSS to remove filter)
          pre.setAttribute('data-js-enhanced', 'true');
          
          // Force remove Shiki inline background styles and apply dark mode
          if (isDark) {
            pre.style.setProperty('background-color', '#1a1f2e', 'important');
            pre.style.setProperty('background', '#1a1f2e', 'important');
          } else {
            pre.style.setProperty('background-color', '#ffffff', 'important');
            pre.style.setProperty('background', '#ffffff', 'important');
          }
          
          const code = pre.querySelector('code');
          if (!code) return;
          
          // Brighten code tokens in dark mode for better contrast
          const tokens = code.querySelectorAll('span[style*="color"]');
          tokens.forEach(token => {
            // Store original color if not already stored
            if (!token.hasAttribute('data-original-color')) {
              token.setAttribute('data-original-color', token.style.color);
            }
            
            // Get the original color
            const originalColor = token.getAttribute('data-original-color');
            
            if (isDark && originalColor) {
              const colorMatch = originalColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
              if (colorMatch) {
                const [_, r, g, b] = colorMatch.map(Number);
                
                // Calculate brightness (perceived luminance)
                const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                
                // If color is very dark (black or near-black), invert to white
                if (brightness < 50) {
                  token.style.setProperty('color', 'rgb(226, 232, 240)', 'important'); // #e2e8f0
                } else {
                  // Otherwise brighten by 50%
                  const newR = Math.min(255, Math.floor(r * 1.5));
                  const newG = Math.min(255, Math.floor(g * 1.5));
                  const newB = Math.min(255, Math.floor(b * 1.5));
                  token.style.setProperty('color', `rgb(${newR}, ${newG}, ${newB})`, 'important');
                }
              }
            } else if (originalColor) {
              // Light mode: restore original color
              token.style.setProperty('color', originalColor, 'important');
            }
          });

          // Extract metadata from the pre tag (populated by Shiki transformer)
          const title = pre.getAttribute('data-title') || '';
          
          if (title) {
              const wrapper = document.createElement('div');
              wrapper.className = 'code-block-wrapper';
              wrapper.setAttribute('data-title', title);
              
              // Apply dark mode background to wrapper
              if (isDark) {
                wrapper.style.backgroundColor = '#1a1f2e';
                wrapper.style.background = '#1a1f2e';
              }
              
              // Copy button
              const copyBtn = document.createElement('button');
              copyBtn.className = 'copy-button';
              copyBtn.textContent = 'Copy';
              
              if (isDark) {
                copyBtn.classList.add('dark'); // Add a class if needed, or rely on parent theme
              }
              
              copyBtn.onclick = async () => {
                  try {
                      await navigator.clipboard.writeText(pre.textContent || '');
                      copyBtn.textContent = 'Copied!';
                      copyBtn.classList.add('copied');
                      
                      // Force inline styles for success state (requested by user)
                      if (isDark) {
                          copyBtn.style.setProperty('color', '#a78bfa', 'important'); // Brand purple light
                          copyBtn.style.setProperty('border-color', '#a78bfa', 'important');
                          copyBtn.style.setProperty('background-color', '#1e293b', 'important');
                      } else {
                          copyBtn.style.setProperty('color', '#6720ff', 'important'); // Brand purple
                          copyBtn.style.setProperty('border-color', '#6720ff', 'important');
                          copyBtn.style.setProperty('background-color', '#ffffff', 'important');
                      }

                      setTimeout(() => {
                          copyBtn.textContent = 'Copy';
                          copyBtn.classList.remove('copied');
                          
                          // Reset inline styles to let CSS classes take over or set to default
                          if (isDark) {
                              copyBtn.style.setProperty('background-color', '#334155', 'important');
                              copyBtn.style.setProperty('color', '#cbd5e1', 'important');
                              copyBtn.style.setProperty('border-color', '#475569', 'important');
                          } else {
                              copyBtn.style.setProperty('background-color', '#ffffff', 'important');
                              copyBtn.style.setProperty('color', '#64748b', 'important');
                              copyBtn.style.setProperty('border-color', '#cbd5e1', 'important');
                          }
                      }, 2000);
                  } catch (err) {
                      console.error('Failed to copy text: ', err);
                  }
              };
              
              pre.parentNode?.insertBefore(wrapper, pre);
              wrapper.appendChild(copyBtn);
              wrapper.appendChild(pre);
              
              // Force styles again after adding to DOM
              setTimeout(() => {
                if (isDark) {
                  copyBtn.style.cssText = `
                    background-color: #334155 !important;
                    background: #334155 !important;
                    color: #cbd5e1 !important;
                    border: 1px solid #475569 !important;
                    border-color: #475569 !important;
                    position: absolute !important;
                    top: 0.625rem !important;
                    right: 0.625rem !important;
                    padding: 0.375rem 0.75rem !important;
                    font-size: 11px !important;
                    font-weight: 600 !important;
                    border-radius: 0.5rem !important;
                    opacity: 1 !important;
                    cursor: pointer !important;
                    z-index: 30 !important;
                    transition: all 0.2s !important;
                  `;
                }
              }, 0);
          } else {
             // Wrap without title for consistancy or just style pre
             const wrapper = document.createElement('div');
              wrapper.className = 'code-block-wrapper';
             
             // Apply dark mode background to wrapper
              if (isDark) {
                wrapper.style.backgroundColor = '#1a1f2e';
                wrapper.style.background = '#1a1f2e';
              }
             
             // Copy button (no title offset)
              const copyBtn = document.createElement('button');
              copyBtn.className = 'copy-button';
              copyBtn.textContent = 'Copy';
              
              // Add data attribute for dark mode
              if (isDark) {
                copyBtn.setAttribute('data-theme', 'dark');
              }
              
              // Apply dark mode styles with cssText (most aggressive method)
              // Apply dark mode styles with cssText
              if (isDark) {
                copyBtn.style.cssText = `
                  background-color: #334155 !important;
                  background: #334155 !important;
                  color: #cbd5e1 !important;
                  border: 1px solid #475569 !important;
                  border-color: #475569 !important;
                  position: absolute !important;
                  top: 0.625rem !important;
                  right: 0.625rem !important;
                  padding: 0.375rem 0.75rem !important;
                  font-size: 11px !important;
                  font-weight: 600 !important;
                  border-radius: 0.5rem !important;
                  opacity: 1 !important;
                  cursor: pointer !important;
                  z-index: 30 !important;
                  transition: all 0.2s !important;
                `;
              } else {
                copyBtn.style.cssText = `
                  background-color: #ffffff !important;
                  background: #ffffff !important;
                  color: #64748b !important;
                  border: 1px solid #cbd5e1 !important;
                  position: absolute !important;
                  top: 0.625rem !important;
                  right: 0.625rem !important;
                  padding: 0.375rem 0.75rem !important;
                  font-size: 11px !important;
                  font-weight: 600 !important;
                  border-radius: 0.5rem !important;
                  opacity: 1 !important;
                  cursor: pointer !important;
                  z-index: 30 !important;
                  transition: all 0.2s !important;
                `;
              }
 
               copyBtn.onclick = async () => {
                  try {
                      await navigator.clipboard.writeText(pre.textContent || '');
                      copyBtn.textContent = 'Copied!';
                      copyBtn.classList.add('copied');
                      
                      // Force inline styles for success state
                      if (isDark) {
                          copyBtn.style.setProperty('color', '#a78bfa', 'important');
                          copyBtn.style.setProperty('border-color', '#a78bfa', 'important');
                          copyBtn.style.setProperty('background-color', '#1e293b', 'important');
                      } else {
                          copyBtn.style.setProperty('color', '#6720ff', 'important');
                          copyBtn.style.setProperty('border-color', '#6720ff', 'important');
                          copyBtn.style.setProperty('background-color', '#ffffff', 'important');
                      }

                      setTimeout(() => {
                          copyBtn.textContent = 'Copy';
                          copyBtn.classList.remove('copied');
                          
                          // Reset inline styles
                          if (isDark) {
                              copyBtn.style.setProperty('background-color', '#334155', 'important');
                              copyBtn.style.setProperty('color', '#cbd5e1', 'important');
                              copyBtn.style.setProperty('border-color', '#475569', 'important');
                          } else {
                              copyBtn.style.setProperty('background-color', '#ffffff', 'important');
                              copyBtn.style.setProperty('color', '#64748b', 'important');
                              copyBtn.style.setProperty('border-color', '#cbd5e1', 'important');
                          }
                      }, 2000);
                  } catch (err) {
                      console.error('Failed to copy text: ', err);
                  }
              };

              pre.parentNode?.insertBefore(wrapper, pre);
              wrapper.appendChild(copyBtn);
              wrapper.appendChild(pre);
              
              // Force styles again after adding to DOM
              setTimeout(() => {
                if (isDark) {
                  copyBtn.style.cssText = `
                    background-color: #334155 !important;
                    background: #334155 !important;
                    color: #cbd5e1 !important;
                    border: 1px solid #475569 !important;
                    border-color: #475569 !important;
                    position: absolute !important;
                    top: 0.625rem !important;
                    right: 0.625rem !important;
                    padding: 0.375rem 0.75rem !important;
                    font-size: 11px !important;
                    font-weight: 600 !important;
                    border-radius: 0.5rem !important;
                    opacity: 1 !important;
                    cursor: pointer !important;
                    z-index: 30 !important;
                    transition: all 0.2s !important;
                  `;
                }
              }, 0);
          }
        });
        
        // Also force styles on all existing copy buttons
        if (isDark) {
          document.querySelectorAll('.copy-button').forEach(btn => {
            (btn as HTMLElement).style.cssText = `
              background-color: #334155 !important;
              background: #334155 !important;
              color: #cbd5e1 !important;
              border: 1px solid #475569 !important;
              border-color: #475569 !important;
              position: absolute !important;
              top: 0.625rem !important;
              right: 0.625rem !important;
              padding: 0.375rem 0.75rem !important;
              font-size: 11px !important;
              font-weight: 600 !important;
              border-radius: 0.5rem !important;
              opacity: 0 !important;
              cursor: pointer !important;
              z-index: 30 !important;
              transition: all 0.2s !important;
            `;
          });
        }
      }
      
      // Re-run enhancement when theme changes
      window.addEventListener('themechange', () => {
        const isDark = document.documentElement.classList.contains('dark');
        
        // Update existing code blocks without recreating wrappers
        document.querySelectorAll('article pre').forEach(pre => {
          // Update background colors
          if (isDark) {
            pre.style.setProperty('background-color', '#1a1f2e', 'important');
            pre.style.setProperty('background', '#1a1f2e', 'important');
          } else {
            pre.style.setProperty('background-color', '#ffffff', 'important');
            pre.style.setProperty('background', '#ffffff', 'important');
          }
          
          // Update token colors
          const code = pre.querySelector('code');
          if (code) {
            const tokens = code.querySelectorAll('span[data-original-color]');
            tokens.forEach(token => {
              const originalColor = token.getAttribute('data-original-color');
              if (isDark && originalColor) {
                const colorMatch = originalColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (colorMatch) {
                  const [_, r, g, b] = colorMatch.map(Number);
                  
                  // Calculate brightness (perceived luminance)
                  const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                  
                  // If color is very dark (black or near-black), convert to light grey
                  if (brightness < 50) {
                    token.style.setProperty('color', 'rgb(226, 232, 240)', 'important'); // #e2e8f0
                  } else {
                    // Otherwise brighten by 50%
                    const newR = Math.min(255, Math.floor(r * 1.5));
                    const newG = Math.min(255, Math.floor(g * 1.5));
                    const newB = Math.min(255, Math.floor(b * 1.5));
                    token.style.setProperty('color', `rgb(${newR}, ${newG}, ${newB})`, 'important');
                  }
                }
              } else if (originalColor) {
                token.style.setProperty('color', originalColor, 'important');
              }
            });
          }
          
          // Update wrapper background if it exists
          const wrapper = pre.closest('.code-block-wrapper');
          if (wrapper) {
            if (isDark) {
              wrapper.style.backgroundColor = '#1a1f2e';
              wrapper.style.background = '#1a1f2e';
            } else {
              wrapper.style.backgroundColor = '#f8fafc';
              wrapper.style.background = '#f8fafc';
            }
          }
        });
      });

      // Run immediately to prevent flash
      enhanceCodeBlocks();
      
      // Also run on Astro page transitions
      document.addEventListener('astro:page-load', enhanceCodeBlocks);
    </script>

    <script>
      function addTableBreakOpportunities() {
        // Skip for API pages to avoid interfering with Stoplight Elements
        if (window.__isApiReferencePage) return;

        const tableCodeElements = document.querySelectorAll('article table code:not(.break-processed), .docs-prose table code:not(.break-processed)');
        
        tableCodeElements.forEach(code => {
          // Mark as processed
          code.classList.add('break-processed');
          
          // Get the text content
          let html = code.innerHTML;
          
          // Don't process if it already has HTML tags (other than wbr)
          if (/<(?!wbr)[^>]+>/i.test(html)) {
            return;
          }
          
          // Insert <wbr> (word break opportunity) after special characters
          // Priority: : ( ) [ ] { } . , ; =
          html = html.replace(/(:|\(|\)|\[|\]|\{|\}|\.|,|;|=)/g, '$1<wbr>');
          
          code.innerHTML = html;
        });
      }
      
      // Run on load and page transitions
      addTableBreakOpportunities();
      document.addEventListener('astro:page-load', addTableBreakOpportunities);
    </script>
    <ZoomLightbox />
  </body>
</html>

<style>
  /* Dark mode specific styles */
  .docs-body {
    background-color: var(--bg-primary);
  }
  
  .sidebar-overlay {
    position: fixed;
    inset: 0;
    background: rgb(0 0 0 / 0.4);
    z-index: 50;
    transition: opacity 0.3s;
    opacity: 0;
    pointer-events: none;
    backdrop-filter: blur(4px);
  }
  
  @media (min-width: 1024px) {
    .sidebar-overlay {
      display: none;
    }
  }
  
  /* Prose styles */
  .docs-prose {
    color: var(--text-primary);
  }
  
  .docs-prose :global(h1),
  .docs-prose :global(h2),
  .docs-prose :global(h3),
  .docs-prose :global(h4),
  .docs-prose :global(h5),
  .docs-prose :global(h6) {
    color: var(--text-primary);
  }
  
  .docs-prose :global(a) {
    color: var(--accent-primary);
  }
  
  .docs-prose :global(strong) {
    color: var(--text-primary);
  }
  
  /* Bold links should show link color, not just bold text color */
  .docs-prose :global(strong a),
  .docs-prose :global(a strong) {
    color: var(--accent-primary);
    font-weight: 700;
  }
  
  .docs-prose :global(blockquote) {
    border-color: var(--accent-primary);
    background: color-mix(in srgb, var(--accent-primary) 5%, transparent);
    color: var(--text-secondary);
  }
  
  .docs-prose :global(img) {
    border-color: var(--border-primary);
  }
  
  .docs-prose :global(code) {
    color: var(--accent-primary);
  }
  
  .docs-prose :global(pre) {
    background: var(--bg-code);
  }

  /* Dark mode code snippet colors - apply immediately to prevent flash */
  :root.dark .docs-prose :global(pre),
  html.dark .docs-prose :global(pre),
  .dark .docs-prose :global(pre) {
    background-color: #1a1f2e !important;
    background: #1a1f2e !important;
  }

  /* Apply brightness filter initially, remove once JS has enhanced */
  :root.dark .docs-prose :global(pre:not([data-js-enhanced]) code span[style*="color"]),
  html.dark .docs-prose :global(pre:not([data-js-enhanced]) code span[style*="color"]),
  .dark .docs-prose :global(pre:not([data-js-enhanced]) code span[style*="color"]) {
    filter: brightness(1.4) !important;
  }
  
  .docs-prose :global(table) {
    color: var(--text-secondary);
    table-layout: auto;
  }
  
  .docs-prose :global(th) {
    color: var(--text-primary);
  }
  
  .docs-prose :global(td) {
    border-color: var(--border-primary);
  }
  
  .docs-prose :global(hr) {
    border-color: var(--border-primary);
  }
  
  /* Tighter spacing at the top of article content */
  .docs-prose > :global(:first-child) {
    margin-top: 0 !important;
  }
  
  /* Instant view transitions - prevent horizontal shift */
  ::view-transition-old(root),
  ::view-transition-new(root) {
    animation-duration: 0ms;
    animation: none;
  }
  
  ::view-transition-old(root) {
    opacity: 0;
  }
  
  ::view-transition-new(root) {
    opacity: 1;
  }
  
  ::view-transition-group(root) {
    animation-duration: 0ms;
  }
  
  /* Ensure body maintains background color during transitions */
  html {
    background-color: var(--bg-primary);
    /* Prevent horizontal jump from scrollbar appearance/disappearance */
    overflow-y: scroll;
    /* Modern approach - reserve space for scrollbar */
    scrollbar-gutter: stable;
  }
  
  /* Lock body width during view transitions to prevent horizontal shift */
  html::view-transition-group(*),
  html::view-transition-old(*),
  html::view-transition-new(*) {
    overflow: clip;
  }
  
  /* Prevent layout shift during view transitions */
  html::view-transition-group(root) {
    animation-duration: 0.2s;
  }
  
  html::view-transition-old(root),
  html::view-transition-new(root) {
    /* Prevent scrollbar from affecting width during transition */
    overflow-y: scroll;
    mix-blend-mode: normal;
  }
  
  /* Force body to maintain scrollbar space during transition */
  html.astro-transitioning,
  html[data-astro-transition] {
    overflow-y: scroll !important;
  }
  
  body {
    /* Ensure body doesn't change width during transitions */
    min-width: 100%;
  }
</style>

<style is:global>
  /* Mobile Search Overlay - Global styles for dynamically created elements */
  .mobile-search-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg-primary);
    z-index: 80;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  
  .mobile-search-overlay[data-open="true"] {
    opacity: 1;
    pointer-events: auto;
  }
  
  .mobile-search-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
  }
  
  .mobile-search-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-primary);
    flex-shrink: 0;
  }
  
  #mobile-search-input {
    color: var(--text-primary) !important;
    background: var(--bg-secondary) !important;
  }
  
  #mobile-search-input::placeholder {
    color: var(--text-tertiary) !important;
  }
  
  .mobile-search-icon {
    color: var(--text-tertiary);
  }
  
  .mobile-search-close-btn {
    color: var(--text-tertiary);
    transition: color 0.2s;
  }
  
  .mobile-search-close-btn:hover {
    color: var(--text-primary);
  }
  
  .mobile-search-results {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
  }
  
  /* Mobile search result items */
  .mobile-search-results a {
    display: block !important;
    padding: 1rem !important;
    margin-bottom: 0.5rem !important;
    border-radius: 0.75rem !important;
    border: 1px solid var(--border-primary) !important;
    background: var(--bg-primary) !important;
    transition: all 0.2s !important;
    text-decoration: none !important;
  }
  
  .mobile-search-results a:hover {
    background: var(--bg-hover) !important;
    border-color: var(--accent-primary) !important;
  }
  
  .mobile-search-results .result-breadcrumbs {
    font-size: 0.75rem !important;
    color: var(--text-tertiary) !important;
    font-weight: 500 !important;
    margin-bottom: 0.25rem !important;
  }
  
  .mobile-search-results .result-title {
    font-size: 0.875rem !important;
    font-weight: 600 !important;
    color: var(--text-primary) !important;
    margin-bottom: 0.25rem !important;
    line-height: 1.4 !important;
  }
  
  .mobile-search-results .result-description {
    font-size: 0.75rem !important;
    color: var(--text-secondary) !important;
    line-height: 1.5 !important;
    display: -webkit-box !important;
    -webkit-line-clamp: 2 !important;
    -webkit-box-orient: vertical !important;
    overflow: hidden !important;
  }
  
  .mobile-search-results a:hover .result-title {
    color: var(--accent-primary) !important;
  }
  
  @media (min-width: 1024px) {
    .mobile-search-overlay {
      display: none;
    }
  }

  /* Right column wrapper - allows sticky children */
  .right-column-wrapper {
    display: none;
    flex-shrink: 0;
    width: 16rem;
    max-width: 18rem;
    position: sticky;
    top: 5.5rem;
    max-height: calc(100vh - 7rem);
    flex-direction: column;
  }

  @media (min-width: 1280px) {
    .right-column-wrapper {
      display: flex;
    }
  }

  /* Medium desktop adjustments to prevent horizontal scroll on zoom */
  @media (min-width: 1024px) and (max-width: 1440px) {
    .right-column-wrapper {
      width: 14rem;
    }
  }
</style>
